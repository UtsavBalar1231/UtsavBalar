---
import WebGLFallback from "@components/WebGLFallback.astro";
---

<canvas id="lightning-storm-canvas" class="lightning-storm-canvas"></canvas>
<div id="lightning-flash" class="lightning-flash"></div>
<WebGLFallback show={false} />

<style>
  /* eslint-disable astro/no-unused-css-selector */
  .lightning-storm-canvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    touch-action: none;
    opacity: 0.8;
    mix-blend-mode: screen;
    contain: strict;
    contain-intrinsic-size: 100vw 100vh;
  }

  .lightning-flash {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    background: radial-gradient(
      ellipse at center,
      rgba(255, 255, 150, 0.6),
      rgba(255, 220, 100, 0.2),
      transparent
    );
    opacity: 0;
    mix-blend-mode: screen;
    transition: opacity 0.15s ease-out;
  }

  /* Class is dynamically added via JavaScript - see line 109 */
  /* eslint-disable-next-line astro/no-unused-css-selector */
  .lightning-flash.active {
    opacity: 1;
    transition: none;
    animation: flashPulse 0.3s ease-out;
  }

  @keyframes flashPulse {
    0% {
      transform: scale(1);
    }
    50% {
      transform: scale(1.05);
    }
    100% {
      transform: scale(1);
    }
  }
  /* eslint-enable astro/no-unused-css-selector */
</style>

<script>
  import { WebGLLightningStorm } from "@/utils/webglLightning";
  import { getRecommendedFPS } from "@/utils/deviceDetection";
  import { hasTargetFPS, hasIsRunning, hasStartMethod, hasStopMethod } from "@/types/webglEffect";
  import { setupEffectLifecycle } from "@/utils/visualEffectLifecycle";

  const effectRef = { current: null as WebGLLightningStorm | null };
  let flashHandler: ((event: Event) => void) | null = null;
  let webgl2Unsupported = false;

  function shouldInitialize(): boolean {
    const theme = document.documentElement.getAttribute("data-theme");
    return theme === "amber-phosphor";
  }

  function initLightningStorm() {
    if (shouldInitialize() && !effectRef.current && !webgl2Unsupported) {
      const recommendedFPS = getRecommendedFPS();

      effectRef.current = new WebGLLightningStorm();
      try {
        effectRef.current.initialize();
      } catch (error) {
        console.error("WebGL 2.0 initialization failed:", error);
        webgl2Unsupported = true;
        const canvas = document.getElementById("lightning-storm-canvas");
        const fallback = document.querySelector(".webgl-fallback");
        if (canvas) canvas.style.display = "none";
        if (fallback) (fallback as HTMLElement).style.display = "block";
        effectRef.current = null;
        return;
      }

      if (hasTargetFPS(effectRef.current)) {
        effectRef.current.targetFPS = recommendedFPS;
      }

      // Setup flash overlay for WebGL lightning
      const flashOverlay = document.getElementById("lightning-flash");
      if (flashOverlay && !flashHandler) {
        flashHandler = () => {
          flashOverlay.classList.add("active");
          setTimeout(() => {
            flashOverlay.classList.remove("active");
          }, 150);
        };
        document.addEventListener("lightning-flash", flashHandler);
      }
    } else if (!shouldInitialize() && effectRef.current) {
      effectRef.current.cleanup();
      effectRef.current = null;
      if (flashHandler) {
        document.removeEventListener("lightning-flash", flashHandler);
        flashHandler = null;
      }
    }
  }

  // Setup effect lifecycle with shared utility
  setupEffectLifecycle({
    canvasId: "lightning-storm-canvas",
    initEffect: initLightningStorm,
    effectRef,
    typeGuards: {
      hasIsRunning,
      hasStartMethod,
      hasStopMethod,
    },
  });
</script>
