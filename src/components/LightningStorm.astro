---
import WebGLFallback from "@components/WebGLFallback.astro";
---

<canvas id="lightning-storm-canvas" class="lightning-storm-canvas"></canvas>
<div id="lightning-flash" class="lightning-flash"></div>
<WebGLFallback show={false} />

<style>
  /* eslint-disable astro/no-unused-css-selector */
  .lightning-storm-canvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    touch-action: none;
    opacity: 0.8;
    mix-blend-mode: screen;
    contain: strict;
    contain-intrinsic-size: 100vw 100vh;
  }

  .lightning-flash {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    background: radial-gradient(
      ellipse at center,
      rgba(255, 255, 150, 0.6),
      rgba(255, 220, 100, 0.2),
      transparent
    );
    opacity: 0;
    mix-blend-mode: screen;
    transition: opacity 0.15s ease-out;
  }

  /* Class is dynamically added via JavaScript - see line 109 */
  /* eslint-disable-next-line astro/no-unused-css-selector */
  .lightning-flash.active {
    opacity: 1;
    transition: none;
    animation: flashPulse 0.3s ease-out;
  }

  @keyframes flashPulse {
    0% {
      transform: scale(1);
    }
    50% {
      transform: scale(1.05);
    }
    100% {
      transform: scale(1);
    }
  }
  /* eslint-enable astro/no-unused-css-selector */
</style>

<script>
  import { WebGLLightningStorm } from "@/utils/webglLightning";
  import { getRecommendedFPS, getBatteryLevel } from "@/utils/deviceDetection";
  import { hasTargetFPS, hasIsRunning, hasStartMethod, hasStopMethod } from "@/types/webglEffect";

  let lightningEffect: WebGLLightningStorm | null = null;
  let themeObserver: MutationObserver | null = null;
  let flashHandler: ((event: Event) => void) | null = null;
  let isInitializing = false;
  let debounceTimer: number | null = null;
  let intersectionObserver: IntersectionObserver | null = null;
  let batteryCheckInterval: number | null = null;
  let webgl2Unsupported = false;

  function shouldInitialize(): boolean {
    const theme = document.documentElement.getAttribute("data-theme");
    return theme === "amber-phosphor";
  }

  async function initLightningStorm() {
    // Prevent concurrent initialization/cleanup
    if (isInitializing) {
      return;
    }

    isInitializing = true;

    try {
      if (shouldInitialize() && !lightningEffect && !webgl2Unsupported) {
        const recommendedFPS = getRecommendedFPS();
        lightningEffect = new WebGLLightningStorm();
        try {
          lightningEffect.initialize();
        } catch (error) {
          console.error("WebGL 2.0 initialization failed:", error);
          webgl2Unsupported = true;
          const canvas = document.getElementById("lightning-storm-canvas");
          const fallback = document.querySelector(".webgl-fallback");
          if (canvas) canvas.style.display = "none";
          if (fallback) (fallback as HTMLElement).style.display = "block";
          lightningEffect = null;
          return;
        }
        if (hasTargetFPS(lightningEffect)) {
          lightningEffect.targetFPS = recommendedFPS;
        }
        setupIntersectionObserver();
        setupBatteryMonitoring();

        // Handle flash overlay for WebGL lightning
        const flashOverlay = document.getElementById("lightning-flash");
        if (flashOverlay && !flashHandler) {
          flashHandler = () => {
            flashOverlay.classList.add("active");
            setTimeout(() => {
              flashOverlay.classList.remove("active");
            }, 150);
          };
          document.addEventListener("lightning-flash", flashHandler);
        }
      } else if (!shouldInitialize() && lightningEffect) {
        cleanupObservers();
        lightningEffect.cleanup();
        lightningEffect = null;
        if (flashHandler) {
          document.removeEventListener("lightning-flash", flashHandler);
          flashHandler = null;
        }
      }
    } finally {
      isInitializing = false;
    }
  }

  function setupIntersectionObserver() {
    const canvas = document.getElementById("lightning-storm-canvas");
    if (!canvas || !lightningEffect) return;
    intersectionObserver = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (hasIsRunning(lightningEffect)) {
            if (entry.isIntersecting) {
              if (hasStartMethod(lightningEffect)) {
                lightningEffect.start();
              }
            } else {
              if (hasStopMethod(lightningEffect)) {
                lightningEffect.stop();
              }
            }
          }
        });
      },
      { threshold: 0.1 }
    );
    intersectionObserver.observe(canvas);
  }

  async function setupBatteryMonitoring() {
    batteryCheckInterval = window.setInterval(async () => {
      const batteryLevel = await getBatteryLevel();
      if (batteryLevel !== null && batteryLevel < 15) {
        if (hasStopMethod(lightningEffect)) {
          lightningEffect.stop();
        }
      }
    }, 30000);
  }

  function cleanupObservers() {
    if (intersectionObserver) {
      intersectionObserver.disconnect();
      intersectionObserver = null;
    }
    if (batteryCheckInterval !== null) {
      clearInterval(batteryCheckInterval);
      batteryCheckInterval = null;
    }
  }

  function debouncedInitLightningStorm() {
    if (debounceTimer !== null) {
      clearTimeout(debounceTimer);
    }

    debounceTimer = window.setTimeout(() => {
      initLightningStorm();
      debounceTimer = null;
    }, 150); // 150ms debounce to match base class
  }

  function setupThemeObserver() {
    themeObserver = new MutationObserver(debouncedInitLightningStorm);
    themeObserver.observe(document.documentElement, {
      attributes: true,
      attributeFilter: ["data-theme"],
    });
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", () => {
      initLightningStorm();
      setupThemeObserver();
    });
  } else {
    initLightningStorm();
    setupThemeObserver();
  }

  document.addEventListener("astro:page-load", initLightningStorm);

  document.addEventListener("astro:before-preparation", () => {
    if (debounceTimer !== null) {
      clearTimeout(debounceTimer);
      debounceTimer = null;
    }

    cleanupObservers();
    lightningEffect?.cleanup();
    lightningEffect = null;
    if (flashHandler) {
      document.removeEventListener("lightning-flash", flashHandler);
      flashHandler = null;
    }
    themeObserver?.disconnect();
    themeObserver = null;
  });
</script>
